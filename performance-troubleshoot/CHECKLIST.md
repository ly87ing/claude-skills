# 高并发系统优化审查检查清单

## 问题类型映射表 (Problem Type Mapping)

| 问题类型 | 重点检查章节 | 关键词 |
|----------|-------------|--------|
| **1. 响应慢** | `[2]`, `[3]`, `[11]`, `[12]` | 锁竞争, IO阻塞, 耗时操作 |
| **2. CPU问题** | `[1]`, `[2]`, `[5]` | 死锁, 自旋, 循环创建 |
| **3. 内存问题** | `[5]`, `[7]` | OOM, GC, 泄露, 缓存 |
| **4. 资源耗尽** | `[5]`, `[7]`, `[12]` | 连接池, 线程池, 句柄 |
| **5. 服务不可用** | `[3]`, `[6]` | 熔断, 降级, 雪崩 |
| **6. 消息积压** | `[4]`, `[11]` | 背压, 消费能力, Mailbox |
| **7. 其他** | 所有章节 | - |

> **使用说明**: Claude 请根据用户反馈的问题类型，优先审查对应章节。

---

## 1. 并发安全与线程模型检查 [CPU] [Concurrent]

### 1.1 线程模型匹配 (Expert)
- [ ] **EventLoop 纯洁性**：在 Netty/Reactor/Vert.x 环境下，通过日志或代码确认 IO 线程是否执行了 JDBC/HTTP 等阻塞操作？(P0 级灾难)
- [ ] **线程数爆炸 (Thread Explosion)**：是否使用了 `CachedThreadPool`？当前线程数是否远超 CPU 核数 (如 > 1000)？这会导致严重的上下文切换 (Context Switch) 消耗 CPU。
- [ ] **伪共享 (False Sharing)**：高频并发修改的变量是否使用了 `@Contended` 或填充对齐？(针对极致性能场景)

### 1.2 原子性与可见性
- [ ] 临界区是否完整保护 (锁、synchronized、mutex)
- [ ] 复合操作是否原子 (检查-执行、读-改-写)
- [ ] 共享变量是否正确同步 (volatile/atomic/channel)

---

## 2. 响应慢与延迟分析 [Response] [Latency]

### 2.1 延迟构成分析 (Expert)
- [ ] **排队延迟 (Queueing Delay)**：线程池队列是否经常满？(任务在队列里等待的时间 > 执行时间)
- [ ] **GC 暂停 (STW)**：慢请求的时间点是否与 Full GC/Young GC 峰值重合？
- [ ] **锁竞争 (Contention)**：是否在热点路径上使用了重量级锁？(查看 Blocked 线程数)

### 2.2 锁与阻塞
- [ ] 锁粒度是否过大 (锁整个方法 vs 锁关键行)
- [ ] 锁内是否包含了 IO 操作或 RPC 调用？(P0 级反模式)
- [ ] 读多写少是否使用了 `ReentrantReadWriteLock` 或 `StampedLock`？

---

## 3. IO/网络与稳定性检查 [Response] [Stability]

### 3.1 级联故障防护 (Expert)
- [ ] **过载保护 (Load Shedding)**：当系统负载(CPU/Memory)超过阈值时，是否能自动丢弃新请求？(P0 级防护)
- [ ] **入口限流 (Rate Limiting)**：是否配置了全局或单用户的 QPS 限制？
- [ ] **重试风暴 (Retry Storm)**：重试是否缺少指数退避 (Exponential Backoff)？是否缺少最大重试次数？
- [ ] **惊群效应 (Thundering Herd)**：缓存失效时，是否所有线程都去查数据库？(是否使用了 Mutex/Singleflight)
- [ ] **舱壁隔离 (Bulkhead)**：核心业务与非核心业务是否共用同一个线程池？(一损俱损风险)
- [ ] **快速失败 (Fast Fail)**：下游超时是否能快速中断当前任务，释放资源？

### 3.2 超时与连接
- [ ] 所有 IO 操作是否有明确的超时设置 (Connect/Read Timeout)
- [ ] 数据库/Redis 连接池是否有关闭检测 (TestOnBorrow/ValidationQuery)

---

## 4. 消息积压检查 [Message]

### 4.1 背压机制
- [ ] 是否有反向压力传递
- [ ] 生产者是否感知消费速度
- [ ] 是否支持阻塞/等待

### 4.2 队列管理
- [ ] 队列容量是否有上限
- [ ] 队列满时策略 (阻塞/丢弃/拒绝)
- [ ] 是否监控队列深度
- [ ] 是否有积压告警

### 4.3 消费能力
- [ ] 消费者是否可扩容
- [ ] 是否支持批量消费
- [ ] 是否支持并行消费
- [ ] 消费失败是否重试

### 4.4 优先级处理
- [ ] 是否支持消息优先级
- [ ] 是否可以丢弃低优先级
- [ ] 关键消息是否保证

---

## 5. 资源耗尽检查 [Resource] [Memory] [CPU]

### 5.1 线程池
- [ ] 最大线程数是否合理
- [ ] 队列大小是否有限
- [ ] 拒绝策略是否合理
- [ ] 是否监控活跃线程数

### 5.2 连接池
- [ ] 最大连接数是否限制
- [ ] 获取连接超时是否设置
- [ ] 连接池满是否告警

### 5.3 内存 (含放大效应)
- [ ] **[核心] 是否存在“对象创建风暴”**：循环内频繁 `new`、`Stream.collect`、`StringBuilder`
- [ ] **[核心] 是否存在“全量传输放大”**：单点变更是否导致整个列表/大对象被重新传输/序列化？(Key Insight)
- [ ] **[核心] 是否存在“数据转换放大”**：在大循环中进行繁重的 POJO -> DTO -> View 转换
- [ ] **[核心] 是否存在“集合拷贝放大”**：每次 Getter 都返回 `new ArrayList(list)` 或 `stream.toList()`
- [ ] **[核心] 是否存在“无效计算”**：数据未发生变化(Dirty Check)，却依然进行了计算、序列化或推送？
- [ ] 缓存是否有大小限制 (maximumSize)
- [ ] 是否有内存使用监控
- [ ] OOM 前是否有降级

### 5.4 磁盘
- [ ] 日志是否有轮转
- [ ] 临时文件是否清理
- [ ] 磁盘满是否告警

### 5.5 云原生/容器环境检查 (Cloud Native) [Expert]
- [ ] **内存限制匹配**：JVM `Xmx` 是否小于 K8s `resources.limits.memory`？(建议预留 20-30% 给非堆内存)
- [ ] **OOMKilled**：检查 `dmesg` 或 K8s Events，是否存在容器被系统 Kill 的记录？
- [ ] **CPU 节流**：K8s `resources.limits.cpu` 是否设置过小？(可通过监控查看 `container_cpu_cfs_throttled_seconds_total`)
- [ ] **DNS 延迟**：是否存在跨集群/跨可用区的高延迟调用？

### 5.6 放大效应专项 (Amplification)
- [ ] **扇出放大**：一次操作是否触发了对 N 个终端/节点的广播？
- [ ] **调用链放大**：顶层一个简单请求，底层是否触发了大量数据库/外部 RPC 调用？
- [ ] **序列化放大**：是否在循环中对复杂对象进行了 JSON/Protobuf 序列化？(JSON 序列化通常极其耗时)
- [ ] **频率放大**：该逻辑是否处于高频触发路径上（如心跳、秒级上报）？
- [ ] **冗余推送**：数据未变化时是否仍然进行了推送？是否缺少版本控制（Version/ETag）？
- [ ] **缺少防抖/合并**：高频小包是否可以合并为大包推送？是否可以增加 Debounce 机制？

### 5.6 GC 压力优化
- [ ] 是否减少短命对象
- [ ] 大对象是否触发 Full GC
- [ ] 是否有对象逃逸分析
- [ ] 堆外内存是否使用 (DirectBuffer)
- [ ] 对象生命周期是否合理

---

## 6. 级联失败检查 [Stability]

### 6.1 依赖隔离
- [ ] 是否使用舱壁模式
- [ ] 不同依赖是否独立线程池
- [ ] 故障是否会扩散

### 6.2 失败传播
- [ ] 慢依赖是否会拖垮调用方
- [ ] 是否会引起雪崩
- [ ] 是否有快速失败机制

### 6.3 健康检查
- [ ] 依赖是否有探活
- [ ] 不健康依赖是否摘除
- [ ] 恢复后是否自动加回

---

## 7. 资源管理检查 [Resource] [Memory]

### 7.1 线程/协程池
- [ ] 是否有关闭/清理方法
- [ ] 大小是否可配置
- [ ] 名称是否便于识别

### 7.2 连接池
- [ ] 连接是否正确归还
- [ ] 是否有泄露检测
- [ ] 关闭顺序是否正确

### 7.3 缓存
- [ ] 是否有过期策略 (TTL)
- [ ] 是否有淘汰策略 (LRU)
- [ ] 缓存穿透/雪崩防护

### 7.4 生命周期
- [ ] 组件销毁时资源是否释放
- [ ] 关闭顺序是否正确
- [ ] 优雅关闭是否支持

---

## 8. 可观测性检查 [All]

### 8.1 日志
- [ ] 级别是否合理
- [ ] 高频日志是否采样
- [ ] 格式是否结构化
- [ ] 异常是否有堆栈

### 8.2 指标
- [ ] 请求量/成功/失败分开统计
- [ ] 延迟有分位数 (P50/P99)
- [ ] 队列深度是否监控
- [ ] 资源使用率是否监控

### 8.3 告警
- [ ] 错误率告警
- [ ] 延迟告警
- [ ] 资源告警
- [ ] 熔断告警

---

## 9. 配置检查 [All]

### 9.1 参数校验
- [ ] 数值范围是否校验
- [ ] 无效配置是否有默认值
- [ ] 配置变更是否记录日志

### 9.2 动态配置
- [ ] 是否支持热更新
- [ ] 变更是否有审计

---

## 10. 文档检查 [All]

### 10.1 必须章节
- [ ] 问题背景 (数据)
- [ ] 核心架构 (流程图)
- [ ] 优化详解 (代码)
- [ ] 配置说明
- [ ] 监控告警
- [ ] 故障处理
- [ ] 压测方案

### 10.2 前置条件
- [ ] 依赖说明
- [ ] 环境要求
- [ ] 配置项说明

---

## 11. Actor 模式检查 [Concurrent] [Message]

### 11.1 消息处理
- [ ] Actor 内是否有阻塞操作
- [ ] 消息处理是否幂等
- [ ] 消息顺序是否有保证要求
- [ ] 是否有消息丢失风险

### 11.2 Mailbox 管理
- [ ] Mailbox 是否有界
- [ ] Mailbox 满时策略 (丢弃/阻塞)
- [ ] 是否监控 Mailbox 深度
- [ ] 是否有积压告警

### 11.3 生命周期
- [ ] Actor 创建是否有成本
- [ ] Actor 是否有超时销毁
- [ ] 父 Actor 失败时子 Actor 处理
- [ ] Actor 重启策略是否合理

### 11.4 监督策略
- [ ] 子 Actor 失败如何处理
- [ ] 重启次数是否有限制
- [ ] 是否有升级策略 (Escalate)
- [ ] 故障是否隔离

---

## 12. 长连接管理检查 [Resource] [Response]

### 12.1 连接管理
- [ ] 最大连接数是否限制
- [ ] 连接是否有超时断开
- [ ] 异常连接是否清理
- [ ] 连接数是否监控

### 12.2 心跳检测
- [ ] 是否有心跳机制
- [ ] 心跳间隔是否合理
- [ ] 心跳超时如何处理
- [ ] 客户端/服务端双向心跳

### 12.3 重连机制
- [ ] 断连后是否自动重连
- [ ] 重连是否有指数退避
- [ ] 重连次数是否有上限
- [ ] 重连风暴是否防护

### 12.4 消息推送
- [ ] 推送失败如何处理
- [ ] 是否有消息确认机制
- [ ] 离线消息如何处理
- [ ] 推送是否有去重

### 12.5 广播优化
- [ ] 多用户相同消息是否复用
- [ ] 序列化是否只做一次
- [ ] 是否支持按房间/分组广播
- [ ] 大消息是否分片

### 12.6 会话管理
- [ ] 用户状态存储位置
- [ ] 会话超时是否清理
- [ ] 多端登录如何处理
- [ ] 会话恢复是否支持

---

## 13. 框架特定检查 (Framework Specifics) [High Priority]

### 13.1 Akka / Actor 模型
- [ ] **Mailbox 积压**：是否使用了 UnboundedMailbox？(高危)
- [ ] **Ask 超时**：`ask` (request-response) 模式是否设置了合理的 Timeout？
- [ ] **Dispatcher 阻塞**：是否在 Actor 内部执行了 JDBC/IO 操作且未切换到 blocking-dispatcher？
- [ ] **消息对象大小**：是否在 Actor 间传递了巨型对象？

### 13.2 Reactive / Reactor / RxJava
- [ ] **无界缓冲**：是否使用了 `EmitterProcessor` (已过时且危险) 或无界队列？
- [ ] **背压丢失**：是否在流处理中使用了 `onBackpressureBuffer` 但未设上限？
- [ ] **线程切换**：是否正确使用了 `publishOn` / `subscribeOn` 避免阻塞 EventLoop？

### 13.3 Netty / 网络编程
- [ ] **ByteBuf 泄露**：是否开启了 ResourceLeakDetector？手动释放是否遗漏？
- [ ] **EventLoop 阻塞**：是否有耗时业务逻辑运行在 IO 线程中？
- [ ] **连接风暴**：是否限制了每秒建连数？

### 13.4 ORM (MyBatis/Hibernate/JPA)
- [ ] **N+1 问题**：循环内查询数据库？
- [ ] **一级缓存陷阱**：Session 是否存活过久导致内存膨胀？
- [ ] **Fetch 策略**：是否意外 Eager Fetch 了大量关联数据？

## 语言特定检查

### Java
- [ ] synchronized vs ReentrantLock 选择
- [ ] ConcurrentHashMap.compute 内无阻塞
- [ ] CompletableFuture 异常处理
- [ ] @PreDestroy 资源关闭
- [ ] 线程池正确关闭

### Go
- [ ] goroutine 泄露检查
- [ ] channel 关闭正确
- [ ] context 超时传递
- [ ] defer 资源关闭
- [ ] sync.WaitGroup 使用正确

### Python
- [ ] GIL 影响考虑
- [ ] asyncio 正确使用
- [ ] 线程池/进程池正确关闭
- [ ] with 语句资源管理

### Node.js
- [ ] Promise 异常处理
- [ ] 事件监听器泄露
- [ ] 流背压处理
- [ ] 优雅关闭
